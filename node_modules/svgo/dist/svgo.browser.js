const visitSkip=Symbol()
const visit=(node,visitor,parentNode)=>{const callbacks=visitor[node.type]
if(callbacks?.enter){const symbol=callbacks.enter(node,parentNode)
if(symbol===visitSkip)return}if(node.type==="root")for(const child of node.children)visit(child,visitor,node)
if(node.type==="element"&&parentNode.children.includes(node))for(const child of node.children)visit(child,visitor,node)
callbacks?.exit&&callbacks.exit(node,parentNode)}
const invokePlugins=(ast,info,plugins,overrides,globalOverrides)=>{for(const plugin of plugins){const override=overrides?.[plugin.name]
if(override===false)continue
const params={...plugin.params,...globalOverrides,...override}
const visitor=plugin.fn(ast,params,info)
visitor!=null&&visit(ast,visitor)}}
const createPreset=({name:name,plugins:plugins})=>({name:name,isPreset:true,plugins:Object.freeze(plugins),fn:(ast,params,info)=>{const{floatPrecision:floatPrecision,overrides:overrides}=params
const globalOverrides={}
floatPrecision!=null&&(globalOverrides.floatPrecision=floatPrecision)
if(overrides){const pluginNames=plugins.map((({name:name})=>name))
for(const pluginName of Object.keys(overrides))pluginNames.includes(pluginName)||console.warn(`You are trying to configure ${pluginName} which is not part of ${name}.\nTry to put it before or after, for example\n\nplugins: [\n  {\n    name: '${name}',\n  },\n  '${pluginName}'\n]\n`)}invokePlugins(ast,info,plugins,overrides,globalOverrides)}})
var ElementType;(function(ElementType){ElementType["Root"]="root"
ElementType["Text"]="text"
ElementType["Directive"]="directive"
ElementType["Comment"]="comment"
ElementType["Script"]="script"
ElementType["Style"]="style"
ElementType["Tag"]="tag"
ElementType["CDATA"]="cdata"
ElementType["Doctype"]="doctype"})(ElementType||(ElementType={}))
function isTag$2(elem){return elem.type===ElementType.Tag||elem.type===ElementType.Script||elem.type===ElementType.Style}const Root=ElementType.Root
const Text=ElementType.Text
const Directive=ElementType.Directive
const Comment$4=ElementType.Comment
const Script=ElementType.Script
const Style=ElementType.Style
const Tag=ElementType.Tag
const CDATA=ElementType.CDATA
const Doctype=ElementType.Doctype
function isTag$1(node){return isTag$2(node)}function isCDATA(node){return node.type===ElementType.CDATA}function isText(node){return node.type===ElementType.Text}function isComment(node){return node.type===ElementType.Comment}function isDocument(node){return node.type===ElementType.Root}function hasChildren(node){return Object.prototype.hasOwnProperty.call(node,"children")}const xmlReplacer=/["&'<>$\x80-\uFFFF]/g
const xmlCodeMap=new Map([[34,"&quot;"],[38,"&amp;"],[39,"&apos;"],[60,"&lt;"],[62,"&gt;"]])
const getCodePoint=String.prototype.codePointAt!=null?(str,index)=>str.codePointAt(index):(c,index)=>(c.charCodeAt(index)&0xfc00)===0xd800?0x400*(c.charCodeAt(index)-0xd800)+c.charCodeAt(index+1)-0xdc00+0x10000:c.charCodeAt(index)
function encodeXML(str){let ret=""
let lastIdx=0
let match
while((match=xmlReplacer.exec(str))!==null){const i=match.index
const char=str.charCodeAt(i)
const next=xmlCodeMap.get(char)
if(next!==void 0){ret+=str.substring(lastIdx,i)+next
lastIdx=i+1}else{ret+=`${str.substring(lastIdx,i)}&#x${getCodePoint(str,i).toString(16)};`
lastIdx=xmlReplacer.lastIndex+=Number((char&0xfc00)===0xd800)}}return ret+str.substr(lastIdx)}function getEscaper(regex,map){return function escape(data){let match
let lastIdx=0
let result=""
while(match=regex.exec(data)){lastIdx!==match.index&&(result+=data.substring(lastIdx,match.index))
result+=map.get(match[0].charCodeAt(0))
lastIdx=match.index+1}return result+data.substring(lastIdx)}}const escapeAttribute=getEscaper(/["&\u00A0]/g,new Map([[34,"&quot;"],[38,"&amp;"],[160,"&nbsp;"]]))
const escapeText=getEscaper(/[&<>\u00A0]/g,new Map([[38,"&amp;"],[60,"&lt;"],[62,"&gt;"],[160,"&nbsp;"]]))
const elementNames=new Map(["altGlyph","altGlyphDef","altGlyphItem","animateColor","animateMotion","animateTransform","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","glyphRef","linearGradient","radialGradient","textPath"].map((val=>[val.toLowerCase(),val])))
const attributeNames=new Map(["definitionURL","attributeName","attributeType","baseFrequency","baseProfile","calcMode","clipPathUnits","diffuseConstant","edgeMode","filterUnits","glyphRef","gradientTransform","gradientUnits","kernelMatrix","kernelUnitLength","keyPoints","keySplines","keyTimes","lengthAdjust","limitingConeAngle","markerHeight","markerUnits","markerWidth","maskContentUnits","maskUnits","numOctaves","pathLength","patternContentUnits","patternTransform","patternUnits","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","preserveAspectRatio","primitiveUnits","refX","refY","repeatCount","repeatDur","requiredExtensions","requiredFeatures","specularConstant","specularExponent","sp